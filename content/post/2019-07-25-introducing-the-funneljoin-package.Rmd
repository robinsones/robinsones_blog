---
title: Introducing the funneljoin package
author: Emily Robinson
date: '2019-07-25'
slug: introducing-the-funneljoin-package
categories: []
tags:
  - R
  - Code
---

I created the package with [David Robinson](https://twitter.com/drob) and [Anthony Baker](https://www.linkedin.com/in/awbaker1/) in an afternoon hack-a-thon and am the current maintainer. 

The goal of funneljoin is to make it easy to analyze behavior funnels. For example, maybe you're interested in finding the people who visit a page and then register. Or you want all the times people click on an item and add it to their cart within 2 days. Or you want to find the last page someone visited before subscribing. All of these are possible with funneljoin's `after_join`,  `funnel_start`, and `funnel_step` functions. 

We'll use funneljoin to analyze data about all Stack Overflow questions and answers (including their other tags) with the tag R. The data was downloaded from Kaggle [here](https://www.kaggle.com/stackoverflow/rquestions/downloads/rquestions.zip/3). 
```{r}
library(knitr)
opts_chunk$set(message = FALSE)
library(tidyverse)
devtools::install_github("robinsones/funneljoin")
library(funneljoin)
answers <- read_csv("Answers.csv")
questions <- read_csv("Questions.csv")
tags <- read_csv("Tags.csv")
```

Let's take a quick look at the questions and answers dataset. 

```{r}
questions
```

```{r}
answers 
```

Before I dive into the analysis, I'm going to use the janitor's package `clean_names()` function to convert the column names to snake case and `%<>%` to modify the datasets. I'll also get rid of the rows where user id is missing. 

```{r}
library(magrittr)
questions %<>%
  janitor::clean_names() %>%
  filter(!is.na(owner_user_id))

answers %<>%
  janitor::clean_names() %>%
  filter(!is.na(owner_user_id))
```

## After join 

Let's start with a relatively simple question - how many people who ask a question later answer one? To look at this, we'll need to link the questions with the answers table using the OwnerUserId and their CreationDate. We will use funneljoin's `after_join` function.

```{r}
after_join(questions, 
                answers,
                by_time = "creation_date",
                by_user = "owner_user_id",
                type = "first-firstafter",
                mode = "left")
```

The first two arguments are the table we're joining, with the table with the first event being first. We then specify what the time and user id columns are and the mode of the join (e.g. left, inner, anti). 

The power of `funneljoin` comes in its `type` argument, which allows you to switch between types of funnels easily. In this case, we wanted only the first question someone asked and then wanted to know the first answer they gave afterward. We wanted to keep all users even if they never answered a question later, which is why we did a left join. 

Now to answer the question, let's get a count by what percent of rows don't have an `id.y`, meaning they never answered a question. We'll use the funneljoin's `summarize_conversions` function, where you specify what column indicates whether someone "converted" (in this case answered a question) and returns the total number of users (`nb_users`), the number of conversions (`nb_conversions`), and the percent converted (`pct_converted`). 

```{r}
after_join(questions, 
                answers,
                by_time = "creation_date",
                by_user = "owner_user_id",
                type = "first-firstafter",
                mode = "left") %>%
  summarize_conversions(converted = id.y)
```

We see that of the approximately 60,000 users that asked an R question, 22.7% percent later went on to answer one. 

How long does it take for people to answer their first question? We can add `gap_col = TRUE` to `after_join` to add a column, `.gap`, which is the gap between events (in seconds). We'll also switch from from using the argument `mode` to specify the type of join to changing to a wrapper function, `after_left_join()`. 

```{r}
questions %>%
  after_left_join(answers,
                  by_time = "creation_date",
                  by_user = "owner_user_id",
                  type = "first-firstafter",
                  gap_col = TRUE) %>%
  mutate(gap_hours = .gap  / 3600) %>%
  ggplot(aes(x = gap_hours)) + 
  geom_histogram() + 
  scale_x_log10(breaks = c(1, 24, 24 * 7, 24 * 7 * 30), 
                     labels = c("1 hour", "1 day", "1 week", "1 month")) + 
  labs(x = "",
       y = "Number of users",
       title = "What's the gap between someone's first StackOverflow question and their first answer?",
       subtitle = "Only for questions tagged with R")
```

We can get an idea from this graph what percentage of people who ask a question answer one within a week, or we could filter our data to get an exact answer. To make it even easier though, we can use the `max_gap` argument in `after_join()` to specify that someone needs to have answered a question within a week from their data to be joined. `max_gap` takes either a `difftime` or an integer reprsenting the gap in seconds. 

```{r}
after_join(questions, 
           answers,
           by_time = "creation_date",
           by_user = "owner_user_id",
           type = "first-firstafter",
           mode = "left",
           max_gap = as.difftime(1, units = "weeks")) %>%
  summarize_conversions(converted = id.y)
```

Now we see that only 8.9% answer an R question within a week of asking their first one. 

We might be curious is this varies by the score of the question. Before doing summarize_conversions, we can group by the score. There are some scores that only appear once (e.g. -18), so we'll filter for only scores where there were more than 100 questions. 

```{r}
after_join(questions, 
           answers,
           by_time = "creation_date",
           by_user = "owner_user_id",
           type = "first-firstafter",
           mode = "left") %>%
  group_by(score.x) %>%
  summarize_conversions(converted = id.y) %>%
  filter(nb_users > 100) %>%
  ggplot(aes(x = score.x, y = pct_converted)) + 
  geom_line() + 
  geom_point(aes(size = nb_users)) + 
  scale_y_continuous(labels = scales::percent) + 
  labs(y = "% who later answering a question",
      x = "Score on a user's first question",
      title = "The higher someone's score on their first question, the more likely they are to answer a question",
      subtitle = "Only for questions tagged with R",
      size = "Number of users") + 
  expand_limits(y = 0)
```

Most people's first questions have a score between -1 and 4, but for those who manager to score higher, they're more likely to answer a question later. As always, you have to be careful of any claims of causality: it could be that more experienced R users are more likely to ask better questions and to later have answers. 

We've been looking so far at people's answers after they've asked a question. But are there people who answer a question before they ever ask one? We can examine this with a `after_right_join` (to keep everyone who asks a question) to see what percent have answered one before. 

```{r}
answers %>%
  after_join(questions,
           by_time = "creation_date",
           by_user = "owner_user_id",
           type = "first-firstafter",
           mode = "right") %>%
  summarize_conversions(id.x)
```

Yes, 5.07% of people who ask a question have answered one previously. 

Because we've been using `first-firstafter`, we've only been getting one row per user. For people who answer questions after asking one, let's find out how many they answer. We'll switch our query to an `after_inner_join` with a type `first-any`. Each user will only have one question, their first, as we used a `first-Y` type. But it has one row per answer they gave afterwards. 

```{r}
questions %>%
  after_join(answers,
           by_time = "creation_date",
           by_user = "owner_user_id",
           type = "first-any",
           mode = "inner") %>%
  count(owner_user_id) %>%
  ggplot(aes(n)) + 
  geom_histogram() + 
  scale_x_log10() + 
  labs(x = "Number of answers",
       y = "Number of users",
       title = "How many questions do people answer after they ask their first one?",
       subtitle = "Only for questions tagged with R on StackOverflow")
```

Not surprisingly, we see people mostly answer only 1 or 2 questions, with a long-tail of power users answering 100+ questions. 

## Funnel step

Sometimes your data is in one dataset instead of two. While you could filter and then join the data to itself with `after_join`, we've created `funnel_start` and `funnel_step` as a wrapper to make that process easier. 